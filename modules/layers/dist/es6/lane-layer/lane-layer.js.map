{"version":3,"sources":["../../../src/lane-layer/lane-layer.js"],"names":["PathLayer","GL","Vector3","defaultProps","highPrecisionDash","getColor2","type","value","getWidth","getDashArray2","LaneLayer","getShaders","shaders","vs","replace","fs","inject","initializeState","context","getAttributeManager","addInstanced","instanceStrokeWidths","size","accessor","defaultValue","instanceColors2","props","colorFormat","length","UNSIGNED_BYTE","normalized","instanceStartRatio","update","calculateStartRatios","instanceDashArrays","instanceDashArrays2","draw","params","model","state","attributes","getAttributes","setUniforms","strokeIndex","setAttributes","instanceColors","attribute","constant","Float32Array","numInstances","viewport","startPositions","endPositions","instanceTypes","target","startPoint","endPoint","totalLength","i","set","copy","projectPosition","segmentLength","distance","layerName"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {PathLayer} from '@deck.gl/layers';\nimport GL from '@luma.gl/constants';\nimport {Vector3} from 'math.gl';\n\nconst defaultProps = {\n  ...PathLayer.defaultProps,\n\n  highPrecisionDash: false,\n\n  getColor2: {type: 'accessor', value: [0, 0, 0, 255]},\n  getWidth: {type: 'accessor', value: [1, 0, 0]},\n  getDashArray2: {type: 'accessor', value: [0, 0]}\n};\n\nexport default class LaneLayer extends PathLayer {\n  getShaders() {\n    const shaders = super.getShaders();\n\n    shaders.vs = shaders.vs\n      .replace('attribute float instanceStrokeWidths', 'attribute vec3 instanceStrokeWidths')\n      .replace('attribute vec2 instanceDashArrays', 'attribute vec4 instanceDashArrays')\n      .replace('varying vec2 vDashArray', 'varying vec4 vDashArray')\n      .replace(\n        'instanceStrokeWidths * widthScale',\n        '(instanceStrokeWidths.x + instanceStrokeWidths.y + instanceStrokeWidths.z) * widthScale'\n      );\n\n    // TODO - move default dash array handling to an extension\n    shaders.fs = shaders.fs\n      .replace(\n        /bool dash_isFragInGap[\\s\\S]*?\\n\\}/,\n        `\nbool dash_isFragInGap() {\n  float solid1 = vDashArray.x;\n  float gap1 = solid1 + vDashArray.y;\n  float solid2 = gap1 + vDashArray.z;\n  float unitLength = solid2 + vDashArray.w;\n\n  if (unitLength == 0.0 || vDashArray.y == 0.0) {\n    return false;\n  }\n\n  unitLength = mix(\n    unitLength,\n    vPathLength / round(vPathLength / unitLength),\n    alignMode\n  );\n\n  float offset = mix(vPathOffset, vDashArray.x / 2.0, alignMode);\n  float unitPosition = mod2(vPathPosition.y + offset, unitLength);\n\n  return unitPosition > solid1 && unitPosition < gap1 || unitPosition > solid2;\n}\n`\n      )\n      .replace('varying vec2 vDashArray', 'varying vec4 vDashArray');\n\n    shaders.inject = {\n      'vs:#decl': `\nuniform float strokeIndex;\nattribute float instanceStartRatio;\nvarying vec2 vWidth;\nvarying float vPathOffset;\n`,\n      'fs:#decl': `\nvarying vec2 vWidth;\nvarying float vPathOffset;\n`,\n      'vs:#main-end': `\n  float totalWidth = instanceStrokeWidths.x + instanceStrokeWidths.y + instanceStrokeWidths.z;\n  if (strokeIndex == 0.0) {\n    vWidth = vec2(0.0, instanceStrokeWidths.x / totalWidth);\n  } else {\n    vWidth = vec2(1.0 - instanceStrokeWidths.z / totalWidth, 1.0);\n  }\n  // map to [-1.0, 1.0] space\n  vWidth = vWidth * 2.0 - 1.0;\n  vPathOffset = vPathLength * instanceStartRatio;\n`,\n      'fs:#main-start': `\n  if (vPathPosition.x < vWidth.x || vPathPosition.x > vWidth.y) {\n    discard;\n  }\n`\n    };\n\n    return shaders;\n  }\n\n  initializeState(context) {\n    super.initializeState(context);\n\n    this.getAttributeManager().addInstanced({\n      instanceStrokeWidths: {\n        size: 3,\n        accessor: 'getWidth',\n        defaultValue: [1, 0, 0]\n      },\n      instanceColors2: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        accessor: 'getColor2',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceStartRatio: {\n        size: 1,\n        update: this.calculateStartRatios\n      },\n      instanceDashArrays: {size: 4, accessor: 'getDashArray'},\n      instanceDashArrays2: {size: 4, accessor: 'getDashArray2'}\n    });\n  }\n\n  draw(params) {\n    const {model} = this.state;\n    const attributes = this.getAttributeManager().getAttributes();\n    model.setUniforms({\n      strokeIndex: 0\n    });\n    model.setAttributes({\n      instanceColors: attributes.instanceColors,\n      instanceDashArrays: attributes.instanceDashArrays\n    });\n    super.draw(params);\n\n    model.setUniforms({\n      strokeIndex: 1\n    });\n    model.setAttributes({\n      instanceColors: attributes.instanceColors2,\n      instanceDashArrays: attributes.instanceDashArrays2\n    });\n    model.draw();\n  }\n\n  calculateStartRatios(attribute) {\n    if (!this.props.highPrecisionDash) {\n      attribute.constant = true;\n      attribute.value = new Float32Array(1);\n      return;\n    }\n\n    const {numInstances} = this.state;\n    const {viewport} = this.context;\n\n    let {startPositions, endPositions, instanceTypes} = this.getAttributeManager().getAttributes();\n    startPositions = startPositions.value;\n    endPositions = endPositions.value;\n    instanceTypes = instanceTypes.value;\n\n    const target = attribute.value;\n\n    const startPoint = new Vector3();\n    const endPoint = new Vector3();\n    let totalLength = 0;\n\n    for (let i = 0; i < numInstances; i++) {\n      startPoint.set(\n        startPositions[i * 3 + 3],\n        startPositions[i * 3 + 4],\n        startPositions[i * 3 + 5]\n      );\n\n      endPoint.set(\n        (endPoint[0] = endPositions[i * 3]),\n        (endPoint[1] = endPositions[i * 3 + 1]),\n        (endPoint[2] = endPositions[i * 3 + 2])\n      );\n\n      startPoint.copy(viewport.projectPosition(startPoint));\n      endPoint.copy(viewport.projectPosition(endPoint));\n\n      const segmentLength = startPoint.distance(endPoint);\n\n      target[i] = segmentLength ? totalLength / segmentLength : 0;\n\n      if (instanceTypes[i] <= 1) {\n        totalLength += segmentLength;\n      } else {\n        totalLength = 0;\n      }\n    }\n  }\n}\n\nLaneLayer.layerName = 'LaneLayer';\nLaneLayer.defaultProps = defaultProps;\n"],"file":"lane-layer.js"}