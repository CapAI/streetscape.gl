{"version":3,"sources":["../../../src/lane-layer/lane-layer.js"],"names":["PathLayer","GL","Vector3","defaultProps","highPrecisionDash","getColor2","type","value","getWidth","getDashArray2","LaneLayer","shaders","vs","replace","fs","inject","context","getAttributeManager","addInstanced","instanceStrokeWidths","size","accessor","defaultValue","instanceColors2","props","colorFormat","length","UNSIGNED_BYTE","normalized","instanceStartRatio","update","calculateStartRatios","instanceDashArrays","instanceDashArrays2","params","model","state","attributes","getAttributes","setUniforms","strokeIndex","setAttributes","instanceColors","draw","attribute","constant","Float32Array","numInstances","viewport","startPositions","endPositions","instanceTypes","target","startPoint","endPoint","totalLength","i","set","copy","projectPosition","segmentLength","distance","layerName"],"mappings":"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","sourcesContent":["// Copyright (c) 2019 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {PathLayer} from '@deck.gl/layers';\nimport GL from '@luma.gl/constants';\nimport {Vector3} from 'math.gl';\n\nconst defaultProps = {\n  ...PathLayer.defaultProps,\n\n  highPrecisionDash: false,\n\n  getColor2: {type: 'accessor', value: [0, 0, 0, 255]},\n  getWidth: {type: 'accessor', value: [1, 0, 0]},\n  getDashArray2: {type: 'accessor', value: [0, 0]}\n};\n\nexport default class LaneLayer extends PathLayer {\n  getShaders() {\n    const shaders = super.getShaders();\n\n    shaders.vs = shaders.vs\n      .replace('attribute float instanceStrokeWidths', 'attribute vec3 instanceStrokeWidths')\n      .replace('attribute vec2 instanceDashArrays', 'attribute vec4 instanceDashArrays')\n      .replace('varying vec2 vDashArray', 'varying vec4 vDashArray')\n      .replace(\n        'instanceStrokeWidths * widthScale',\n        '(instanceStrokeWidths.x + instanceStrokeWidths.y + instanceStrokeWidths.z) * widthScale'\n      );\n\n    // TODO - move default dash array handling to an extension\n    shaders.fs = shaders.fs\n      .replace(\n        /bool dash_isFragInGap[\\s\\S]*?\\n\\}/,\n        `\nbool dash_isFragInGap() {\n  float solid1 = vDashArray.x;\n  float gap1 = solid1 + vDashArray.y;\n  float solid2 = gap1 + vDashArray.z;\n  float unitLength = solid2 + vDashArray.w;\n\n  if (unitLength == 0.0 || vDashArray.y == 0.0) {\n    return false;\n  }\n\n  unitLength = mix(\n    unitLength,\n    vPathLength / round(vPathLength / unitLength),\n    alignMode\n  );\n\n  float offset = mix(vPathOffset, vDashArray.x / 2.0, alignMode);\n  float unitPosition = mod2(vPathPosition.y + offset, unitLength);\n\n  return unitPosition > solid1 && unitPosition < gap1 || unitPosition > solid2;\n}\n`\n      )\n      .replace('varying vec2 vDashArray', 'varying vec4 vDashArray');\n\n    shaders.inject = {\n      'vs:#decl': `\nuniform float strokeIndex;\nattribute float instanceStartRatio;\nvarying vec2 vWidth;\nvarying float vPathOffset;\n`,\n      'fs:#decl': `\nvarying vec2 vWidth;\nvarying float vPathOffset;\n`,\n      'vs:#main-end': `\n  float totalWidth = instanceStrokeWidths.x + instanceStrokeWidths.y + instanceStrokeWidths.z;\n  if (strokeIndex == 0.0) {\n    vWidth = vec2(0.0, instanceStrokeWidths.x / totalWidth);\n  } else {\n    vWidth = vec2(1.0 - instanceStrokeWidths.z / totalWidth, 1.0);\n  }\n  // map to [-1.0, 1.0] space\n  vWidth = vWidth * 2.0 - 1.0;\n  vPathOffset = vPathLength * instanceStartRatio;\n`,\n      'fs:#main-start': `\n  if (vPathPosition.x < vWidth.x || vPathPosition.x > vWidth.y) {\n    discard;\n  }\n`\n    };\n\n    return shaders;\n  }\n\n  initializeState(context) {\n    super.initializeState(context);\n\n    this.getAttributeManager().addInstanced({\n      instanceStrokeWidths: {\n        size: 3,\n        accessor: 'getWidth',\n        defaultValue: [1, 0, 0]\n      },\n      instanceColors2: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        accessor: 'getColor2',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceStartRatio: {\n        size: 1,\n        update: this.calculateStartRatios\n      },\n      instanceDashArrays: {size: 4, accessor: 'getDashArray'},\n      instanceDashArrays2: {size: 4, accessor: 'getDashArray2'}\n    });\n  }\n\n  draw(params) {\n    const {model} = this.state;\n    const attributes = this.getAttributeManager().getAttributes();\n    model.setUniforms({\n      strokeIndex: 0\n    });\n    model.setAttributes({\n      instanceColors: attributes.instanceColors,\n      instanceDashArrays: attributes.instanceDashArrays\n    });\n    super.draw(params);\n\n    model.setUniforms({\n      strokeIndex: 1\n    });\n    model.setAttributes({\n      instanceColors: attributes.instanceColors2,\n      instanceDashArrays: attributes.instanceDashArrays2\n    });\n    model.draw();\n  }\n\n  calculateStartRatios(attribute) {\n    if (!this.props.highPrecisionDash) {\n      attribute.constant = true;\n      attribute.value = new Float32Array(1);\n      return;\n    }\n\n    const {numInstances} = this.state;\n    const {viewport} = this.context;\n\n    let {startPositions, endPositions, instanceTypes} = this.getAttributeManager().getAttributes();\n    startPositions = startPositions.value;\n    endPositions = endPositions.value;\n    instanceTypes = instanceTypes.value;\n\n    const target = attribute.value;\n\n    const startPoint = new Vector3();\n    const endPoint = new Vector3();\n    let totalLength = 0;\n\n    for (let i = 0; i < numInstances; i++) {\n      startPoint.set(\n        startPositions[i * 3 + 3],\n        startPositions[i * 3 + 4],\n        startPositions[i * 3 + 5]\n      );\n\n      endPoint.set(\n        (endPoint[0] = endPositions[i * 3]),\n        (endPoint[1] = endPositions[i * 3 + 1]),\n        (endPoint[2] = endPositions[i * 3 + 2])\n      );\n\n      startPoint.copy(viewport.projectPosition(startPoint));\n      endPoint.copy(viewport.projectPosition(endPoint));\n\n      const segmentLength = startPoint.distance(endPoint);\n\n      target[i] = segmentLength ? totalLength / segmentLength : 0;\n\n      if (instanceTypes[i] <= 1) {\n        totalLength += segmentLength;\n      } else {\n        totalLength = 0;\n      }\n    }\n  }\n}\n\nLaneLayer.layerName = 'LaneLayer';\nLaneLayer.defaultProps = defaultProps;\n"],"file":"lane-layer.js"}